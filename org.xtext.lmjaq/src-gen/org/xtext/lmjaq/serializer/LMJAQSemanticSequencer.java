/*
 * generated by Xtext 2.25.0
 */
package org.xtext.lmjaq.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.lmjaq.lMJAQ.AbstractClass;
import org.xtext.lmjaq.lMJAQ.AbstractClassType;
import org.xtext.lmjaq.lMJAQ.AbstractElement;
import org.xtext.lmjaq.lMJAQ.AbstractProperty;
import org.xtext.lmjaq.lMJAQ.ClassReference;
import org.xtext.lmjaq.lMJAQ.LMJAQPackage;
import org.xtext.lmjaq.lMJAQ.Model;
import org.xtext.lmjaq.lMJAQ.PackageDeclaration;
import org.xtext.lmjaq.lMJAQ.Property;
import org.xtext.lmjaq.services.LMJAQGrammarAccess;

@SuppressWarnings("all")
public class LMJAQSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LMJAQGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LMJAQPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LMJAQPackage.ABSTRACT_CLASS:
				sequence_AbstractClass(context, (AbstractClass) semanticObject); 
				return; 
			case LMJAQPackage.ABSTRACT_CLASS_TYPE:
				sequence_AbstractClassType(context, (AbstractClassType) semanticObject); 
				return; 
			case LMJAQPackage.ABSTRACT_ELEMENT:
				sequence_AbstractElement(context, (AbstractElement) semanticObject); 
				return; 
			case LMJAQPackage.ABSTRACT_PROPERTY:
				sequence_AbstractProperty(context, (AbstractProperty) semanticObject); 
				return; 
			case LMJAQPackage.CLASS_REFERENCE:
				sequence_ClassReference(context, (ClassReference) semanticObject); 
				return; 
			case LMJAQPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case LMJAQPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case LMJAQPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractClassType returns AbstractClassType
	 *
	 * Constraint:
	 *     (
	 *         type=Tela | 
	 *         type=Objeto | 
	 *         type=Recurso | 
	 *         type=Componente | 
	 *         type=EventoComplexo | 
	 *         type=ConfigGeral | 
	 *         type=Estado | 
	 *         type=Item | 
	 *         type=Alternativa | 
	 *         type=Questao
	 *     )
	 */
	protected void sequence_AbstractClassType(ISerializationContext context, AbstractClassType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractClass returns AbstractClass
	 *
	 * Constraint:
	 *     (type=AbstractClassType (name=ID | name=EVENT_CODE) abstractProperties+=AbstractProperty*)
	 */
	protected void sequence_AbstractClass(ISerializationContext context, AbstractClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AbstractElement
	 *
	 * Constraint:
	 *     (elementType=PackageDeclaration | elementType=AbstractClass)
	 */
	protected void sequence_AbstractElement(ISerializationContext context, AbstractElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractProperty returns AbstractProperty
	 *
	 * Constraint:
	 *     ((format=ClassReference | format=Property) values+=Value*)
	 */
	protected void sequence_AbstractProperty(ISerializationContext context, AbstractProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassReference returns ClassReference
	 *
	 * Constraint:
	 *     type=AbstractClassType
	 */
	protected void sequence_ClassReference(ISerializationContext context, ClassReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LMJAQPackage.Literals.CLASS_REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LMJAQPackage.Literals.CLASS_REFERENCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassReferenceAccess().getTypeAbstractClassTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     abstractElments+=AbstractElement+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LMJAQPackage.Literals.PACKAGE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LMJAQPackage.Literals.PACKAGE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageDeclarationAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (
	 *         propertyType=Posicao | 
	 *         propertyType=estaAtivo | 
	 *         propertyType=Caminho | 
	 *         propertyType=TamanhoDaFonte | 
	 *         propertyType=Conteudo | 
	 *         propertyType=Tamanho | 
	 *         propertyType=IU | 
	 *         propertyType=EventoSimples | 
	 *         propertyType=ComprimentoDaTela | 
	 *         propertyType=AlturaDaTela | 
	 *         propertyType=Efeito | 
	 *         propertyType=EstadosAfetados | 
	 *         propertyType=EstadoInicial | 
	 *         propertyType=EstadoFinal | 
	 *         propertyType=ProximoEstados | 
	 *         propertyType=FormatoQuiz | 
	 *         propertyType=Enunciado | 
	 *         propertyType=Resposta
	 *     )
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
