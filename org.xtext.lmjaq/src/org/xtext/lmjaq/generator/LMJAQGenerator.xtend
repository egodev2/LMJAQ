/*
 * generated by Xtext 2.25.0
 */
package org.xtext.lmjaq.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.lmjaq.lMJAQ.Model
import org.xtext.lmjaq.lMJAQ.AbstractClass
import org.xtext.lmjaq.lMJAQ.AbstractElement
import org.xtext.lmjaq.lMJAQ.LMJAQPackage
import org.xtext.lmjaq.lMJAQ.PackageDeclaration
import org.xtext.lmjaq.lMJAQ.AbstractProperty
import org.xtext.lmjaq.lMJAQ.ClassReference
import org.xtext.lmjaq.lMJAQ.Property
import org.eclipse.emf.ecore.EObject
import java.util.List
import org.eclipse.emf.common.util.EList
import java.util.Collections
import java.util.ArrayList
import java.util.HashMap
import java.util.Dictionary
import java.util.Hashtable
import org.xtext.lmjaq.services.LMJAQGrammarAccess.GatilhoElements

/**
 * Generates code from your model files on save.
 * 
 * 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */

class LMJAQGenerator extends AbstractGenerator {
	

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context)
	{
		
		// Get all AbstractElements (Pacakge or AbstractClass)
		val abstractElementList = resource.allContents.toIterable.filter(AbstractElement)	
		var currentOutput = ""
		var packageCnt = 0
		
		var List<String> packageDeclarationList = new ArrayList
		
		CSHARPGenerator.InitializeGatilhoList
		
		// WARNING - HARD CODED E:\\eclispe-workspace\\runtime-New_configuration
		CSHARPGenerator.InitializeEclispeProjectPath("E:\\eclispe-workspace\\runtime-New_configuration")
		
		CSHARPGenerator.InitializeFileAcess(fsa)
		
		SimpleEventHandler.InitializeHandler

		for(ae : abstractElementList) 
		{
			// If it's a class, proced to wirte its JSON
			if(LMJAQPackage.Literals.ABSTRACT_CLASS.name.equalsIgnoreCase(ae.elementType.eClass.name))
			{
					
					// Put all contents inside the selected abstract class in  alist
					val acList = ae.eContents.filter(AbstractClass)
					
					// Start the JSON signature and compile all added packages.
					currentOutput += "{" + compilePackagesToModel(currentOutput, packageDeclarationList, packageCnt)
											
					if(acList.length != 0)
					{
							//Get The abstract class from (ae)
						 	val ac =  acList.get(0)
						 	
						 	// C# Behaviour code
						 	if(ac.isGatilho())
						 	{
						 		if(ac.type.type.equalsIgnoreCase("AoClicar"))
								{
									var AbstractProperty ap = ac.eAllContents.toIterable.filter(AbstractProperty).get(0)
									
									// fsa.generateFile("teste" + packageCnt +  ".txt", pd)
									var GatilhoMethodData ged = new GatilhoMethodData(
								    	ac.name,
								    	ap.values.get(0).cleanString,
								    	ap.values.get(1))
								    	
									ged.WriteDataToFile(ac.name, fsa)	
								}
						 	}
						 	// Generate Class + Finish JSON
						 	fsa.generateFile("models/" + ac.type.type + "/" + ac.name + ".json", 
											compileAbstractClassToModel(currentOutput,ac,fsa))
						 	
						 					
							// Refresh for next package -> class 
							currentOutput = ""
							packageDeclarationList = new ArrayList
							packageCnt = 0
					}
						
			}
			else
			{
				// Otherwise, it's a package declaration, we save for compilation when AbstractElement is a class.
				val pd = getPackageDeclaration(ae,fsa)
				
				if(pd !== null) 
				{
					packageDeclarationList.add(pd)
					
					// currentOutput += pdList.get(0).compilePackageToModel().toString()	
					packageCnt += 1
					
				}
				// fsa.generateFile("teste" + packageCnt +  ".txt", pd)		
			}
		}
		
		
		
		// C# Model Representation for Unity
		CSHARPGenerator.generateCSHarpDataContainers(fsa)
		
		// C# Generation For Comportamento, Gatilho and Event
		CSHARPGenerator.generateEventsClasses()

	}
	
	def compileAbstractClassToModel(String currentOutput, AbstractClass ac, IFileSystemAccess2 fsa)
	{
		
		var AbstractPropertySorter apSorter = new AbstractPropertySorter(ac,fsa)
		
		// DEBUG ONLY
		var String allKeys = ""
		for(key : apSorter.crMap.keySet)
		{
			allKeys += key
		}	
		fsa.generateFile("keysAC.txt",allKeys)
		// END DEBUG ONLY 
		
		return currentOutput
			+
		'''
			"class":
			{
				"type" : "«ac.type.type»",
				"name" : "«ac.name»",
				"properties" : 
				{
					«compilePropertiesNameToModel(apSorter.properties)»
					«compilePropertiesValuesToModel(apSorter.properties)»
				},
				"references" : 
				{
					«FOR gt : apSorter.groupedTypes.keySet SEPARATOR','»
						"«gt»" : [«compileAllGroupReferences(gt, apSorter.groupedTypes,apSorter.crMap)»]
					«ENDFOR»
				}
			}
		}
		'''
	}
	
	def isGatilho(AbstractClass ac)
	{
		
		if(ac.type.type.equalsIgnoreCase("AoClicar"))
		{
			return true;	
		}
		
		return false
	}
	
	// For each type that belongs to the OBJETOS, RECURSOS and EVENTOS group, compile its mapped references
	def compileAllGroupReferences(String gt, HashMap <String, ArrayList<String>> groupedTypes, HashMap <String, ArrayList<String>> crMap)
	{
		'''
		«FOR t : groupedTypes.get(gt) SEPARATOR ',' »«compileEachReference(t,crMap)»«ENDFOR»
		'''
	}
	
	def compileEachReference(String t, HashMap <String, ArrayList<String>> crMap)
	{
		'''«FOR r : crMap.get(t) SEPARATOR ',' »"«r»"«ENDFOR»'''
	}
	
	def compileTypeReference(String classReference, HashMap <String, ArrayList<String>> crMap)
	{
		return '''«crMap.get(classReference)»'''
	}
	
	def compilePropertiesNameToModel(ArrayList<AbstractProperty> apList)
	{
		'''
		"HashKeys" : [«FOR ap : apList SEPARATOR','»
			«ap.compilePropertyKeyToModel()»
		«ENDFOR»],
		'''
	}
	
	def compilePropertiesValuesToModel(ArrayList<AbstractProperty> apList)
	{
		'''
		"HashValues" : [«FOR ap : apList SEPARATOR ','»
			«ap.compilePropertyValueToModel()»
		«ENDFOR»]
		'''
	}
	
	
	def compilePackagesToModel(String currentOutput, List <String> packageList, Integer pcnt)
	{
		if(pcnt == 0)
		{
			return currentOutput +
			'''"packages" : [],'''
		}
		else
		{
			return currentOutput +
			'''"packages" : [«FOR pd : packageList SEPARATOR ','»"«pd»"«ENDFOR»],
			'''
		}
	}
	
	def compilePropertyKeyToModel(AbstractProperty ap)
	{
		val p = ap.getPropertyName()
		
		'''
			«IF p.equalsIgnoreCase('posicao')»
					    "X","Y"
			«ELSEIF p.equalsIgnoreCase('tamanho')»
						"W","H"
			«ELSEIF p.equalsIgnoreCase('conteudo')»
						"conteudo"
			«ELSEIF p.equalsIgnoreCase('EventoSimples')»
						"Evento"
			«ELSE»
						"«p»"
			«ENDIF»
		'''
	}
	
	def compilePropertyValueToModel(AbstractProperty ap)
	{	
		
		val p = ap.getPropertyName()
		
		'''
			«IF p.equalsIgnoreCase('posicao')»
					    «ap.compilePosicaoToModel()»
			«ELSEIF p.equalsIgnoreCase('tamanho')»
						«ap.compileTamanhoToModel()»
			«ELSEIF p.equalsIgnoreCase('conteudo')»
						«ap.compileTextValuesToModel()»
			«ELSEIF p.equalsIgnoreCase('iu')»
						"«ap.compileIUToModel()»"
			«ELSEIF p.equalsIgnoreCase('EventoSimples')»
						«ap.compileEventoSimplesToModel()»
			«ELSE»
						"«ap.compileValuesToModel()»"
			«ENDIF»
		'''
	}
	
	def compilePosicaoToModel(AbstractProperty ap)
	{
		val posXY = ap.values
		'''"«posXY.get(0)»","«posXY.get(1)»"'''
	}
	
	def compileTamanhoToModel(AbstractProperty ap)
	{
		val tamWH = ap.values
		'''"«tamWH.get(0)»","«tamWH.get(1)»"'''
	}
	
	def compileIUToModel(AbstractProperty ap)
	{
		var valueWithNoBrackets = ap.values.get(0).replaceAll("\\[","").replaceAll("\\]","")
		'''«valueWithNoBrackets»'''
	}
	
	def compileEventoSimplesToModel(AbstractProperty ap)
	{
		val eventTypeAndReference = ap.values
		
		'''"«eventTypeAndReference.get(0)»","«eventTypeAndReference.get(1)»"'''
	}
	
	def compileTextValuesToModel(AbstractProperty ap)
	{
		'''«ap.values.get(0)»'''
	}
	

	def compileValuesToModel(AbstractProperty ap)
	{
		'''«FOR value : ap.values SEPARATOR ' '»«value»«ENDFOR»'''
	}
	
	// AUXILIA
	
	def protected getPackageDeclaration(AbstractElement ae, IFileSystemAccess2 fsa)
	{
		val pdList = ae.eContents.filter(PackageDeclaration)
		
		if(pdList.length != 0)
		{	
				return pdList.get(0).name
		}
		return null
	}
	
	
	def protected getPropertyName(AbstractProperty ap)
	{
		return ap.eContents.filter(Property).get(0).propertyType
	}
	
	def protected cleanString(String s)
	{
		return s.replaceAll("\\[","").replaceAll("\\]","")
	}
	
}
